//Better approach TC:O(N) and SC:O(N) 
//here I used simple approach of using two pointers keeping pos neg index concept in mind and a separate array 
class Solution {
    public int[] rearrangeArray(int[] nums) {
         int[] result = new int[nums.length];
        int posIdx=0;
        int negIdx=1;
       for(int i=0;i<nums.length;i++){
            if(nums[i]>0){
                result[posIdx]=nums[i];
                posIdx+=2;
            }
            else{
                result[negIdx]=nums[i];
                negIdx+=2;
            }
       }
       return result;
    }
}
//imp I thought upto finding next possible pos or neg value but swap will distort the order but shifitng by one won't so do that but keeping even odd index in mind cleared the vision .
// Time Limit is exceeding
class Solution {
    public int[] rearrangeArray(int[] nums) {
       for(int i=0;i<nums.length;i++){
        if(i%2==0){                
            if(nums[i]>0){
                continue;
            }
            else{
                int idx=nextPos(nums,i);
                  if(idx == -1) continue;
                int temp = nums[idx];
          for(int k = idx; k > i; k--) {
            nums[k] = nums[k - 1];
              }
           nums[i] = temp;
            }
        }
        else{
            if(nums[i] < 0) {
            continue;
        }
        else {
            int idx = nextNeg(nums, i);

            if(idx == -1) continue;   // no negative found

            int temp = nums[idx];

            for(int k = idx; k > i; k--) {
                nums[k] = nums[k - 1];
            }

            nums[i] = temp;
        }

        }
       }
       
       return nums; 
    }
    int nextPos(int []nums,int i){
   
    for(int j=i+1;j<nums.length;j++){
        if(nums[j]>0)
        {
            return j;
        }
    }
    return -1; 

}
int nextNeg(int []nums,int i){
    for(int j = i + 1; j < nums.length; j++) {
        if(nums[j] < 0) {
            return j;
        }
    }

    return -1; 
}
}
