/*
//this is my approach of this question which got complex while i tried solving the errors which i was getting during it's solution 
TC:O(n^2)
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        int max_sum=Integer.MIN_VALUE;
   for(int i=0;i<nums.length;i++){
         int sum=0;
         int length=0;
         if((nums.length)-i>k ||(nums.length)-i ==k){
            for(int j=i;j<nums.length;j++){
                if(length!=k){
                sum+=nums[j];
                length++;
                }
            }
            if(sum>max_sum){
                    max_sum=sum;
                }
        }
   }
        return (double)max_sum/k;
    }
}*/
/*Now this is second approach not optimised but atleast acceptable because it give time compleixity O(n*k) 
for(int i = 0; i <= nums.length - k; i++){  //this logic i learnt to identify the last valid start postion for subarray

    int sum = 0;
    for(int j = i; j < i + k; j++){
        sum += nums[j];
    }
    if(sum > max_sum){
        max_sum = sum;
    }
}
*/ 
//Optimised
class Solution {
    public double findMaxAverage(int[] nums, int k) {
     int sum=0;
     for(int i=0;i<k;i++){
        sum+=nums[i];
     }
     int maxSum=sum;
     for(int i=k;i<nums.length;i++){
        sum=sum-nums[i-k]+nums[i];
        maxSum=Math.max(maxSum,sum);
     }
     return (double)maxSum/k;
    }
}
