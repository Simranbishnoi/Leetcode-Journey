//Optimised approach 
//I learnt how to build intiution with keen obervation 
class Solution {
    public void nextPermutation(int[] nums) {
        int idx=-1;
        int n=nums.length;
        for(int i=n-2;i>=0;i--){       //1.finding longer prefix match from right side 
            if(nums[i]<nums[i+1]){
                idx=i;                //break point till where the greater order number is possible
                break;
            }
        }
        if(idx==-1){                    //if array is already at lst stage [5,4,3,2,1] then no brk point found reverse [1,2,3,4,5] 
            reverse(nums,0,n-1);
            return;
        }
        for(int i=n-1;i>=idx;i--){       //we just found idx now from right of it finding the just greater element thns swap with idx th element now right side we have all greater plus one smaller swapped (should be the just next order ) so sort (reverse) 
            if(nums[i]>nums[idx]){
                int temp=nums[i];
                nums[i]=nums[idx];
                nums[idx]=temp;
                break;
            }
        }
        reverse(nums,idx+1,n-1);
       
    }
     void reverse(int []nums,int l,int r){
            while(l<r){
                int temp=nums[l];
                nums[l]=nums[r];
                nums[r]=temp;
                l++;
                r--;
            }
        }
}
//Brute force for this problem is first generating all permutations and sorting them in lexicographical order then finding the next permutation by linear search but time complexitiy inc too much 
